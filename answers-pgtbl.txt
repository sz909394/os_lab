Question 1:
Explain the output of vmprint in terms of Fig 3-4 from the text. What does page 0
contain? What is in page 2? When running in user mode, could the process read/write the
memory mapped by page 1?

Answer for Q1:
1. what is the output of vmprint in terms of Fig 3-4 from the text?
the program "/init" 's pagetable

2. page 0 contain "/init" program code and data
3. page 1 is guard page, When running in user mode, the process can't access this page.
4. page 2 is user stack for "/init", it contain "the arguments and the address of arguments of /init", and return address for "/init".
**************************************************************************************************************************************

Question 2:
Explain why the third test srcva + len < srcva is necessary in copyin_new() : give
values for srcva and len for which the first two test fail (i.e., they will not cause to return
-1) but for which the third one is true (resulting in returning -1).

Answer for Q2:
copyin_new check this:
  if (srcva >= p->sz || srcva+len >= p->sz || srcva+len < srcva)
    return -1;

srcva >= p->sz and srcva+len >= p->sz : 这个容易理解，你不能操作超出原本分配给你的地址空间.
srcva+len < srcva : 这个有点理解难度，目的是防止这样的情况:
用户进程选择了合法的srcva, 然后精心设计len， 使得 srcva+len 后 发生 uint64 溢出，且溢出后的地址刚好是 user process 原本禁止访问的地址.

